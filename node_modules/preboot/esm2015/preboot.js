import { APP_BOOTSTRAP_LISTENER, ApplicationRef, Inject, InjectionToken, NgModule, Optional, PLATFORM_ID } from '@angular/core';
import { DOCUMENT, isPlatformBrowser, isPlatformServer } from '@angular/common';
import { take } from 'rxjs/operators/take';
import { filter } from 'rxjs/operators/filter';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Attempt to generate key from node position in the DOM
 * @param {?} nodeContext
 * @return {?}
 */
function getNodeKeyForPreboot(nodeContext) {
    const /** @type {?} */ ancestors = [];
    const /** @type {?} */ root = nodeContext.root;
    const /** @type {?} */ node = nodeContext.node;
    let /** @type {?} */ temp = node;
    // walk up the tree from the target node up to the root
    while (temp && temp !== root.serverNode && temp !== root.clientNode) {
        ancestors.push(temp);
        temp = /** @type {?} */ (temp.parentNode);
    }
    // note: if temp doesn't exist here it means root node wasn't found
    if (temp) {
        ancestors.push(temp);
    }
    // now go backwards starting from the root, appending the appName to unique
    // identify the node later..
    const /** @type {?} */ name = node.nodeName || 'unknown';
    let /** @type {?} */ key = name + '_' + root.serverSelector;
    const /** @type {?} */ len = ancestors.length;
    for (let /** @type {?} */ i = len - 1; i >= 0; i--) {
        temp = ancestors[i];
        if (temp.childNodes && i > 0) {
            for (let /** @type {?} */ j = 0; j < temp.childNodes.length; j++) {
                if (temp.childNodes[j] === ancestors[i - 1]) {
                    key += '_s' + (j + 1);
                    break;
                }
            }
        }
    }
    return key;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const PREBOOT_NONCE = new InjectionToken('PrebootNonce');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function _window() {
    return {
        prebootData: (/** @type {?} */ (window))['prebootData'],
        prebootStarted: false,
        getComputedStyle: window.getComputedStyle,
        document: document
    };
}
class EventReplayer {
    constructor() {
        this.clientNodeCache = {};
        this.replayStarted = false;
    }
    /**
     * Window setting and getter to facilitate testing of window
     * in non-browser environments
     * @param {?} win
     * @return {?}
     */
    setWindow(win) {
        this.win = win;
    }
    /**
     * Window setting and getter to facilitate testing of window
     * in non-browser environments
     * @return {?}
     */
    getWindow() {
        if (!this.win) {
            this.win = _window();
        }
        return this.win;
    }
    /**
     * Replay all events for all apps. this can only be run once.
     * if called multiple times, will only do something once
     * @return {?}
     */
    replayAll() {
        if (this.replayStarted) {
            return;
        }
        else {
            this.replayStarted = true;
        }
        // loop through each of the preboot apps
        const /** @type {?} */ prebootData = this.getWindow().prebootData || {};
        const /** @type {?} */ apps = prebootData.apps || [];
        apps.forEach(appData => this.replayForApp(appData));
        // once all events have been replayed and buffers switched, then we cleanup preboot
        this.cleanup(prebootData);
    }
    /**
     * Replay all events for one app (most of the time there is just one app)
     * @param {?} appData
     * @return {?}
     */
    replayForApp(appData) {
        appData = /** @type {?} */ ((appData || {}));
        // try catch around events b/c even if error occurs, we still move forward
        try {
            const /** @type {?} */ root = /** @type {?} */ ((appData.root || {}));
            const /** @type {?} */ events = appData.events || [];
            // some client side frameworks (like Angular 1 w UI Router) will replace
            // elements, so we need to re-get client root just to be safe
            const /** @type {?} */ doc = this.getWindow().document;
            const /** @type {?} */ clientSelector = root.clientSelector;
            if (clientSelector != null) {
                root.clientNode = /** @type {?} */ (doc.querySelector(clientSelector));
            }
            // replay all the events from the server view onto the client view
            events.forEach(event => this.replayEvent(appData, event));
        }
        catch (/** @type {?} */ ex) {
            console.error(ex);
        }
        // if we are buffering, switch the buffers
        this.switchBuffer(appData);
    }
    /**
     * Replay one particular event
     * @param {?} appData
     * @param {?} prebootEvent
     * @return {?}
     */
    replayEvent(appData, prebootEvent) {
        appData = /** @type {?} */ ((appData || {}));
        prebootEvent = /** @type {?} */ ((prebootEvent || {}));
        const /** @type {?} */ event = /** @type {?} */ (prebootEvent.event);
        const /** @type {?} */ serverNode = prebootEvent.node || {};
        const /** @type {?} */ nodeKey = prebootEvent.nodeKey;
        const /** @type {?} */ clientNode = this.findClientNode({
            root: appData.root,
            node: serverNode,
            nodeKey: nodeKey
        });
        // if client node can't be found, log a warning
        if (!clientNode) {
            console.warn(`Trying to dispatch event ${event.type} to node ${nodeKey}
        but could not find client node. Server node is: ${serverNode}`);
            return;
        }
        // now dispatch events and whatnot to the client node
        (/** @type {?} */ (clientNode)).checked = serverNode.checked;
        (/** @type {?} */ (clientNode)).selected = serverNode.selected;
        (/** @type {?} */ (clientNode)).value = serverNode.value;
        clientNode.dispatchEvent(event);
    }
    /**
     * Switch the buffer for one particular app (i.e. display the client
     * view and destroy the server view)
     * @param {?} appData
     * @return {?}
     */
    switchBuffer(appData) {
        appData = /** @type {?} */ ((appData || {}));
        const /** @type {?} */ root = /** @type {?} */ ((appData.root || {}));
        const /** @type {?} */ serverView = root.serverNode;
        const /** @type {?} */ clientView = root.clientNode;
        // if no client view or the server view is the body or client
        // and server view are the same, then don't do anything and return
        if (!clientView || !serverView || serverView === clientView || serverView.nodeName === 'BODY') {
            return;
        }
        // do a try-catch just in case something messed up
        try {
            // get the server view display mode
            const /** @type {?} */ gcs = this.getWindow().getComputedStyle;
            const /** @type {?} */ display = gcs(serverView).getPropertyValue('display') || 'block';
            // first remove the server view
            serverView.remove ? serverView.remove() : (serverView.style.display = 'none');
            // now add the client view
            clientView.style.display = display;
        }
        catch (/** @type {?} */ ex) {
            console.error(ex);
        }
    }
    /**
     * Finally, set focus, remove all the event listeners and remove
     * any freeze screen that may be there
     * @param {?} prebootData
     * @return {?}
     */
    cleanup(prebootData) {
        prebootData = prebootData || {};
        const /** @type {?} */ listeners = prebootData.listeners || [];
        // set focus on the active node AFTER a small delay to ensure buffer
        // switched
        const /** @type {?} */ activeNode = prebootData.activeNode;
        if (activeNode != null) {
            setTimeout(() => this.setFocus(activeNode), 1);
        }
        // remove all event listeners
        for (const /** @type {?} */ listener of listeners) {
            listener.node.removeEventListener(listener.eventName, listener.handler);
        }
        // remove the freeze overlay if it exists
        const /** @type {?} */ doc = this.getWindow().document;
        const /** @type {?} */ prebootOverlay = /** @type {?} */ (doc.body.querySelector('#prebootOverlay'));
        if (prebootOverlay) {
            prebootOverlay.remove ?
                prebootOverlay.remove() : prebootOverlay.parentNode !== null ?
                prebootOverlay.parentNode.removeChild(prebootOverlay) :
                prebootOverlay.style.display = 'none';
        }
        // clear out the data stored for each app
        prebootData.apps = [];
        this.clientNodeCache = {};
        // send event to document that signals preboot complete
        // constructor is not supported by older browsers ( i.e. IE9-11 )
        // in these browsers, the type of CustomEvent will be "object"
        if (typeof CustomEvent === 'function') {
            const /** @type {?} */ completeEvent = new CustomEvent('PrebootComplete');
            doc.dispatchEvent(completeEvent);
        }
        else {
            console.warn(`Could not dispatch PrebootComplete event.
       You can fix this by including a polyfill for CustomEvent.`);
        }
    }
    /**
     * @param {?} activeNode
     * @return {?}
     */
    setFocus(activeNode) {
        // only do something if there is an active node
        if (!activeNode || !activeNode.node || !activeNode.nodeKey) {
            return;
        }
        // find the client node in the new client view
        const /** @type {?} */ clientNode = this.findClientNode(activeNode);
        if (clientNode) {
            // set focus on the client node
            clientNode.focus();
            // set selection if a modern browser (i.e. IE9+, etc.)
            const /** @type {?} */ selection = activeNode.selection;
            if ((/** @type {?} */ (clientNode)).setSelectionRange && selection) {
                try {
                    (/** @type {?} */ (clientNode))
                        .setSelectionRange(selection.start, selection.end, selection.direction);
                }
                catch (/** @type {?} */ ex) { }
            }
        }
    }
    /**
     * Given a node from the server rendered view, find the equivalent
     * node in the client rendered view. We do this by the following approach:
     *      1. take the name of the server node tag (ex. div or h1 or input)
     *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)
     *      3. use that value as a selector to get all the matching client nodes
     *      4. loop through all client nodes found and for each generate a key value
     *      5. compare the client key to the server key; once there is a match,
     *          we have our client node
     *
     * NOTE: this only works when the client view is almost exactly the same as
     * the server view. we will need an improvement here in the future to account
     * for situations where the client view is different in structure from the
     * server view
     * @param {?} serverNodeContext
     * @return {?}
     */
    findClientNode(serverNodeContext) {
        serverNodeContext = /** @type {?} */ ((serverNodeContext || {}));
        const /** @type {?} */ serverNode = serverNodeContext.node;
        const /** @type {?} */ root = serverNodeContext.root;
        // if no server or client root, don't do anything
        if (!root || !root.serverNode || !root.clientNode) {
            return null;
        }
        // we use the string of the node to compare to the client node & as key in
        // cache
        const /** @type {?} */ serverNodeKey = serverNodeContext.nodeKey || getNodeKeyForPreboot(serverNodeContext);
        // if client node already in cache, return it
        if (this.clientNodeCache[serverNodeKey]) {
            return /** @type {?} */ (this.clientNodeCache[serverNodeKey]);
        }
        // get the selector for client nodes
        const /** @type {?} */ className = (serverNode.className || '').replace('ng-binding', '').trim();
        let /** @type {?} */ selector = serverNode.tagName;
        if (serverNode.id) {
            selector += `#${serverNode.id}`;
        }
        else if (className) {
            selector += `.${className.replace(/ /g, '.')}`;
        }
        // select all possible client nodes and look through them to try and find a
        // match
        const /** @type {?} */ rootClientNode = root.clientNode;
        let /** @type {?} */ clientNodes = rootClientNode.querySelectorAll(selector);
        // if nothing found, then just try the tag name as a final option
        if (!clientNodes.length) {
            console.log(`nothing found for ${selector} so using ${serverNode.tagName}`);
            clientNodes = rootClientNode.querySelectorAll(serverNode.tagName);
        }
        const /** @type {?} */ length = clientNodes.length;
        for (let /** @type {?} */ i = 0; i < length; i++) {
            const /** @type {?} */ clientNode = clientNodes.item(i);
            // get the key for the client node
            const /** @type {?} */ clientNodeKey = getNodeKeyForPreboot({
                root: root,
                node: clientNode
            });
            // if the client node key is exact match for the server node key, then we
            // found the client node
            if (clientNodeKey === serverNodeKey) {
                this.clientNodeCache[serverNodeKey] = clientNode;
                return /** @type {?} */ (clientNode);
            }
        }
        // if we get here and there is one clientNode, use it as a fallback
        if (clientNodes.length === 1) {
            this.clientNodeCache[serverNodeKey] = clientNodes[0];
            return /** @type {?} */ (clientNodes[0]);
        }
        // if we get here it means we couldn't find the client node so give the user
        // a warning
        console.warn(`No matching client node found for ${serverNodeKey}.
       You can fix this by assigning this element a unique id attribute.`);
        return null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Called right away to initialize preboot
 *
 * @param {?} opts All the preboot options
 * @param {?=} win
 * @return {?}
 */
function init(opts, win) {
    const /** @type {?} */ theWindow = /** @type {?} */ ((win || window));
    // add the preboot options to the preboot data and then add the data to
    // the window so it can be used later by the client
    const /** @type {?} */ data = (theWindow.prebootData = /** @type {?} */ ({
        opts: opts,
        listening: true,
        apps: [],
        listeners: []
    }));
    // start up preboot listening as soon as the DOM is ready
    waitUntilReady(data);
}
/**
 * We want to attach event handlers as soon as possible. Unfortunately this
 * means before DOMContentLoaded fires, so we need to look for document.body to
 * exist instead.
 * @param {?} data
 * @param {?=} win
 * @return {?}
 */
function waitUntilReady(data, win) {
    const /** @type {?} */ theWindow = /** @type {?} */ ((win || window));
    const /** @type {?} */ _document = /** @type {?} */ ((theWindow.document || {}));
    if (_document.body) {
        start(data);
    }
    else {
        setTimeout(function () {
            waitUntilReady(data);
        }, 10);
    }
}
/**
 * Start up preboot by going through each app and assigning the appropriate
 * handlers. Normally this wouldn't be called directly, but we have set it up so
 * that it can for older versions of Universal.
 *
 * @param {?} prebootData Global preboot data object that contains options and will
 * have events
 * @param {?=} win Optional param to pass in mock window for testing purposes
 * @return {?}
 */
function start(prebootData, win) {
    const /** @type {?} */ theWindow = /** @type {?} */ ((win || window));
    // only start once
    if (theWindow.prebootStarted) {
        return;
    }
    else {
        theWindow.prebootStarted = true;
    }
    const /** @type {?} */ _document = /** @type {?} */ ((theWindow.document || {}));
    const /** @type {?} */ opts = prebootData.opts || (/** @type {?} */ ({}));
    let /** @type {?} */ eventSelectors = opts.eventSelectors || [];
    // create an overlay that can be used later if a freeze event occurs
    prebootData.overlay = createOverlay(_document);
    // get an array of all the root info
    const /** @type {?} */ appRoots = prebootData.opts ? getAppRoots(_document, prebootData.opts) : [];
    // for each app root
    appRoots.forEach(function (root) {
        // we track all events for each app in the prebootData object which is on
        // the global scope
        const /** @type {?} */ appData = /** @type {?} */ ({ root: root, events: [] });
        if (prebootData.apps) {
            prebootData.apps.push(appData);
        }
        eventSelectors = eventSelectors.map(eventSelector => {
            if (!eventSelector.hasOwnProperty('replay')) {
                eventSelector.replay = true;
            }
            return eventSelector;
        });
        // loop through all the eventSelectors and create event handlers
        eventSelectors.forEach(eventSelector => handleEvents(prebootData, appData, eventSelector));
    });
}
/**
 * Create an overlay div and add it to the DOM so it can be used
 * if a freeze event occurs
 *
 * @param {?} _document The global document object (passed in for testing purposes)
 * @return {?} Element The overlay node is returned
 */
function createOverlay(_document) {
    let /** @type {?} */ overlay = _document.createElement('div');
    overlay.setAttribute('id', 'prebootOverlay');
    overlay.setAttribute('style', 'display:none;position:absolute;left:0;' +
        'top:0;width:100%;height:100%;z-index:999999;background:black;opacity:.3');
    _document.body.appendChild(overlay);
    return overlay;
}
/**
 * Get references to all app root nodes based on input options. Users can
 * initialize preboot either by specifying appRoot which is just one or more
 * selectors for apps. This section option is useful for people that are doing their own
 * buffering (i.e. they have their own client and server view)
 *
 * @param {?} _document The global document object passed in for testing purposes
 * @param {?} opts Options passed in by the user to init()
 * @return {?} ServerClientRoot[] An array of root info for each app
 */
function getAppRoots(_document, opts) {
    const /** @type {?} */ roots = [];
    // loop through any appRoot selectors to add them to the list of roots
    if (opts.appRoot && opts.appRoot.length) {
        const /** @type {?} */ baseList = [];
        const /** @type {?} */ appRootSelectors = baseList.concat(opts.appRoot);
        appRootSelectors.forEach((selector) => roots.push({ serverSelector: selector }));
    }
    // now loop through the roots to get the nodes for each root
    roots.forEach(root => {
        root.serverNode = /** @type {?} */ (_document.querySelector(root.serverSelector));
        root.clientSelector = root.clientSelector || root.serverSelector;
        if (root.clientSelector !== root.serverSelector) {
            // if diff selectors, then just get the client node
            root.clientNode = /** @type {?} */ (_document.querySelector(root.clientSelector));
        }
        else {
            // if we are doing buffering, we need to create the buffer for the client
            // else the client root is the same as the server
            root.clientNode = opts.buffer ? createBuffer(root) : root.serverNode;
        }
        // if no server node found, log error
        if (!root.serverNode) {
            console.log(`No server node found for selector: ${root.serverSelector}`);
        }
    });
    return roots;
}
/**
 * Under given server root, for given selector, record events
 *
 * @param {?} prebootData
 * @param {?} appData
 * @param {?} eventSelector
 * @return {?}
 */
function handleEvents(prebootData, appData, eventSelector) {
    const /** @type {?} */ serverRoot = appData.root.serverNode;
    // don't do anything if no server root
    if (!serverRoot) {
        return;
    }
    // get all nodes under the server root that match the given selector
    const /** @type {?} */ nodes = serverRoot.querySelectorAll(eventSelector.selector);
    // don't do anything if no nodes found
    if (!nodes) {
        return;
    }
    // we want to add an event listener for each node and each event
    for (let /** @type {?} */ i = 0; i < nodes.length; i++) {
        const /** @type {?} */ node = nodes.item(i);
        eventSelector.events.forEach((eventName) => {
            // get the appropriate handler and add it as an event listener
            const /** @type {?} */ handler = createListenHandler(prebootData, eventSelector, appData, node);
            node.addEventListener(eventName, handler);
            // need to keep track of listeners so we can do node.removeEventListener()
            // when preboot done
            if (prebootData.listeners) {
                prebootData.listeners.push({
                    node: /** @type {?} */ (node),
                    eventName,
                    handler
                });
            }
        });
    }
}
/**
 * Create handler for events that we will record
 * @param {?} prebootData
 * @param {?} eventSelector
 * @param {?} appData
 * @param {?} node
 * @return {?}
 */
function createListenHandler(prebootData, eventSelector, appData, node) {
    const /** @type {?} */ CARET_EVENTS = ['keyup', 'keydown', 'focusin', 'mouseup', 'mousedown'];
    const /** @type {?} */ CARET_NODES = ['INPUT', 'TEXTAREA'];
    return function (event) {
        const /** @type {?} */ root = appData.root;
        const /** @type {?} */ eventName = event.type;
        // if no node or no event name or not listening, just return
        if (!node || !eventName) {
            return;
        }
        // if key codes set for eventSelector, then don't do anything if event
        // doesn't include key
        const /** @type {?} */ keyCodes = eventSelector.keyCodes;
        if (keyCodes && keyCodes.length) {
            const /** @type {?} */ matchingKeyCodes = keyCodes.filter(keyCode => event.which === keyCode);
            // if there are not matches (i.e. key entered NOT one of the key codes)
            // then don't do anything
            if (!matchingKeyCodes.length) {
                return;
            }
        }
        // if for a given set of events we are preventing default, do that
        if (eventSelector.preventDefault) {
            event.preventDefault();
        }
        // if an action handler passed in, use that
        if (eventSelector.action) {
            eventSelector.action(node, event);
        }
        // get the node key for a given node
        const /** @type {?} */ nodeKey = getNodeKeyForPreboot({ root: root, node: node });
        // if event on input or text area, record active node
        if (CARET_EVENTS.indexOf(eventName) >= 0 &&
            CARET_NODES.indexOf(node.tagName ? node.tagName : '') >= 0) {
            prebootData.activeNode = {
                root: root,
                node: node,
                nodeKey: nodeKey,
                selection: getSelection(/** @type {?} */ (node))
            };
        }
        else if (eventName !== 'change' && eventName !== 'focusout') {
            prebootData.activeNode = undefined;
        }
        // if we are freezing the UI
        if (eventSelector.freeze) {
            const /** @type {?} */ overlay = /** @type {?} */ (prebootData.overlay);
            // show the overlay
            overlay.style.display = 'block';
            // hide the overlay after 10 seconds just in case preboot.complete() never
            // called
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 10000);
        }
        // we will record events for later replay unless explicitly marked as
        // doNotReplay
        if (eventSelector.replay) {
            appData.events.push({
                node,
                nodeKey,
                event,
                name: eventName
            });
        }
    };
}
/**
 * Get the selection data that is later used to set the cursor after client view
 * is active
 * @param {?} node
 * @return {?}
 */
function getSelection(node) {
    node = node || /** @type {?} */ ({});
    const /** @type {?} */ nodeValue = node.value || '';
    const /** @type {?} */ selection = {
        start: nodeValue.length,
        end: nodeValue.length,
        direction: 'forward'
    };
    // if browser support selectionStart on node (Chrome, FireFox, IE9+)
    try {
        if (node.selectionStart || node.selectionStart === 0) {
            selection.start = node.selectionStart;
            selection.end = node.selectionEnd ? node.selectionEnd : 0;
            selection.direction = node.selectionDirection ? node.selectionDirection : '';
        }
    }
    catch (/** @type {?} */ ex) { }
    return selection;
}
/**
 * Create buffer for a given node
 *
 * @param {?} root All the data related to a particular app
 * @return {?} Returns the root client node.
 */
function createBuffer(root) {
    const /** @type {?} */ serverNode = root.serverNode;
    // if no rootServerNode OR the selector is on the entire html doc or the body
    // OR no parentNode, don't buffer
    if (!serverNode || !serverNode.parentNode ||
        root.serverSelector === 'html' || root.serverSelector === 'body') {
        return /** @type {?} */ (serverNode);
    }
    // create shallow clone of server root
    const /** @type {?} */ rootClientNode = /** @type {?} */ (serverNode.cloneNode(false));
    // we want the client to write to a hidden div until the time for switching
    // the buffers
    rootClientNode.style.display = 'none';
    // insert the client node before the server and return it
    serverNode.parentNode.insertBefore(rootClientNode, serverNode);
    // mark server node as not to be touched by AngularJS - needed for ngUpgrade
    serverNode.setAttribute('ng-non-bindable', '');
    // return the rootClientNode
    return rootClientNode;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const eventRecorder = {
    waitUntilReady,
    start,
    createOverlay,
    getAppRoots,
    handleEvents,
    createListenHandler,
    getSelection,
    createBuffer
};
// exporting default options in case developer wants to use these + custom on
// top
const defaultOptions = /** @type {?} */ ({
    buffer: true,
    minify: true,
    replay: true,
    // these are the default events are are listening for an transfering from
    // server view to client view
    eventSelectors: [
        // for recording changes in form elements
        {
            selector: 'input,textarea',
            events: ['keypress', 'keyup', 'keydown', 'input', 'change']
        },
        { selector: 'select,option', events: ['change'] },
        // when user hits return button in an input box
        {
            selector: 'input',
            events: ['keyup'],
            preventDefault: true,
            keyCodes: [13],
            freeze: true
        },
        // when user submit form (press enter, click on button/input[type="submit"])
        {
            selector: 'form',
            events: ['submit'],
            preventDefault: true,
            freeze: true
        },
        // for tracking focus (no need to replay)
        {
            selector: 'input,textarea',
            events: ['focusin', 'focusout', 'mousedown', 'mouseup'],
            replay: false
        },
        // user clicks on a button
        {
            selector: 'button',
            events: ['click'],
            preventDefault: true,
            freeze: true
        }
    ]
});
/**
 * Get the event recorder code based on all functions in event.recorder.ts
 * and the getNodeKeyForPreboot function.
 * @return {?}
 */
function getEventRecorderCode() {
    const /** @type {?} */ eventRecorderFunctions = [];
    for (const /** @type {?} */ funcName in eventRecorder) {
        if (eventRecorder.hasOwnProperty(funcName)) {
            const /** @type {?} */ fn = (/** @type {?} */ (eventRecorder))[funcName].toString();
            const /** @type {?} */ fnCleaned = fn.replace('common_1.', '');
            eventRecorderFunctions.push(fnCleaned);
        }
    }
    // this is common function used to get the node key
    eventRecorderFunctions.push(getNodeKeyForPreboot.toString());
    // add new line characters for readability
    return '\n\n' + eventRecorderFunctions.join('\n\n') + '\n\n';
}
/**
 * Used by the server side version of preboot. The main purpose
 * is to get the inline code that can be inserted into the server view.
 *
 * @param {?=} customOptions PrebootRecordOptions that override the defaults
 * @return {?} Generated inline preboot code is returned
 */
function getInlinePrebootCode(customOptions) {
    const /** @type {?} */ opts = /** @type {?} */ (assign({}, defaultOptions, customOptions));
    // safety check to make sure options passed in are valid
    validateOptions(opts);
    const /** @type {?} */ optsStr = stringifyWithFunctions(opts);
    const /** @type {?} */ scriptCode = getEventRecorderCode();
    // TODO re-add minification option?
    // wrap inline preboot code with a self executing function in order to create scope
    const /** @type {?} */ initStr = init.toString();
    return `(function() {
      ${scriptCode}
      (${initStr.replace('common_1.', '')}
      )(${optsStr})
    })()`;
}
/**
 * Throw an error if issues with any options
 * @param {?} opts
 * @return {?}
 */
function validateOptions(opts) {
    if (!opts.appRoot || !opts.appRoot.length) {
        throw new Error('The appRoot is missing from preboot options. ' +
            'This is needed to find the root of your application. ' +
            'Set this value in the preboot options to be a selector for the root element of your app.');
    }
}
/**
 * Object.assign() is not fully supporting in TypeScript, so
 * this is just a simple implementation of it
 *
 * @param {?} target The target object
 * @param {...?} optionSets Any number of addition objects that are added on top of the
 * target
 * @return {?} A new object that contains all the merged values
 */
function assign(target, ...optionSets) {
    if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
    }
    const /** @type {?} */ output = Object(target);
    for (let /** @type {?} */ index = 0; index < optionSets.length; index++) {
        const /** @type {?} */ source = optionSets[index];
        if (source !== undefined && source !== null) {
            for (const /** @type {?} */ nextKey in source) {
                if (source.hasOwnProperty && source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                }
            }
        }
    }
    return output;
}
/**
 * Stringify an object and include functions. This is needed since we are
 * letting users pass in options that include custom functions for things like
 * the freeze handler or action when an event occurs
 *
 * @param {?} obj This is the object you want to stringify that includes some
 * functions
 * @return {?} The stringified version of an object
 */
function stringifyWithFunctions(obj) {
    const /** @type {?} */ FUNC_START = 'START_FUNCTION_HERE';
    const /** @type {?} */ FUNC_STOP = 'STOP_FUNCTION_HERE';
    // first stringify except mark off functions with markers
    let /** @type {?} */ str = JSON.stringify(obj, function (_key, value) {
        // if the value is a function, we want to wrap it with markers
        if (!!(value && value.constructor && value.call && value.apply)) {
            return FUNC_START + value.toString() + FUNC_STOP;
        }
        else {
            return value;
        }
    });
    // now we use the markers to replace function strings with actual functions
    let /** @type {?} */ startFuncIdx = str.indexOf(FUNC_START);
    let /** @type {?} */ stopFuncIdx;
    let /** @type {?} */ fn;
    while (startFuncIdx >= 0) {
        stopFuncIdx = str.indexOf(FUNC_STOP);
        // pull string out
        fn = str.substring(startFuncIdx + FUNC_START.length, stopFuncIdx);
        fn = fn.replace(/\\n/g, '\n');
        str = str.substring(0, startFuncIdx - 1) + fn +
            str.substring(stopFuncIdx + FUNC_STOP.length + 1);
        startFuncIdx = str.indexOf(FUNC_START);
    }
    return str;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const PREBOOT_SCRIPT_ID = 'preboot-inline-script';
const PREBOOT_OPTIONS = new InjectionToken('PrebootOptions');
/**
 * @param {?} doc
 * @param {?} prebootOpts
 * @param {?} nonce
 * @param {?} platformId
 * @param {?} appRef
 * @param {?} eventReplayer
 * @return {?}
 */
function PREBOOT_FACTORY(doc, prebootOpts, nonce, platformId, appRef, eventReplayer) {
    return () => {
        if (isPlatformServer(platformId)) {
            const /** @type {?} */ inlineCode = getInlinePrebootCode(prebootOpts);
            const /** @type {?} */ script = doc.createElement('script');
            if (nonce) {
                (/** @type {?} */ (script))['nonce'] = nonce;
            }
            script.id = PREBOOT_SCRIPT_ID;
            script.textContent = inlineCode;
            const /** @type {?} */ existingScripts = doc.querySelectorAll(`#${PREBOOT_SCRIPT_ID}`);
            // Check to see if a preboot script is already inlined before adding
            // it to the DOM. If it is, update the nonce to be current
            if (existingScripts.length === 0) {
                doc.head.appendChild(script);
            }
            else if (existingScripts.length > 0 && nonce) {
                (/** @type {?} */ (existingScripts[0]))['nonce'] = nonce;
            }
        }
        if (isPlatformBrowser(platformId)) {
            const /** @type {?} */ replay = prebootOpts.replay != null ? prebootOpts.replay : true;
            if (replay) {
                appRef.isStable
                    .pipe(filter(stable => stable), take(1)).subscribe(() => {
                    eventReplayer.replayAll();
                });
            }
        }
    };
}
const PREBOOT_PROVIDER = {
    provide: /** @type {?} */ (APP_BOOTSTRAP_LISTENER),
    useFactory: PREBOOT_FACTORY,
    deps: [
        DOCUMENT,
        PREBOOT_OPTIONS,
        [new Optional(), new Inject(PREBOOT_NONCE)],
        PLATFORM_ID,
        ApplicationRef,
        EventReplayer,
    ],
    multi: true
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PrebootModule {
    /**
     * @param {?} opts
     * @return {?}
     */
    static withConfig(opts) {
        return {
            ngModule: PrebootModule,
            providers: [{ provide: PREBOOT_OPTIONS, useValue: opts }]
        };
    }
}
PrebootModule.decorators = [
    { type: NgModule, args: [{
                providers: [EventReplayer, PREBOOT_PROVIDER]
            },] },
];
/** @nocollapse */
PrebootModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { getNodeKeyForPreboot, PREBOOT_NONCE, _window, EventReplayer, init, waitUntilReady, start, createOverlay, getAppRoots, handleEvents, createListenHandler, getSelection, createBuffer, defaultOptions, getEventRecorderCode, getInlinePrebootCode, validateOptions, assign, stringifyWithFunctions, PrebootModule, PREBOOT_FACTORY as ɵb, PREBOOT_OPTIONS as ɵa, PREBOOT_PROVIDER as ɵc };
//# sourceMappingURL=preboot.js.map
