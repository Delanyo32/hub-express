{"version":3,"file":"preboot.umd.min.js","sources":["../../out-tsc/lib/common/get-node-key.ts","../../out-tsc/lib/common/tokens.ts","../../out-tsc/lib/api/event.replayer.ts","../../out-tsc/lib/api/event.recorder.ts","../../out-tsc/lib/api/inline.preboot.code.ts","../../out-tsc/lib/provider.ts","../../out-tsc/lib/module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NodeContext } from './preboot.interfaces';\n\n/**\n * Attempt to generate key from node position in the DOM\n */\nexport function getNodeKeyForPreboot(nodeContext: NodeContext): string {\n  const ancestors: Element[] = [];\n  const root = nodeContext.root;\n  const node = nodeContext.node;\n  let temp: Element | null = node;\n\n  // walk up the tree from the target node up to the root\n  while (temp && temp !== root.serverNode && temp !== root.clientNode) {\n    ancestors.push(temp);\n    temp = temp.parentNode as Element;\n  }\n\n  // note: if temp doesn't exist here it means root node wasn't found\n  if (temp) {\n    ancestors.push(temp);\n  }\n\n  // now go backwards starting from the root, appending the appName to unique\n  // identify the node later..\n  const name = node.nodeName || 'unknown';\n  let key = name + '_' + root.serverSelector;\n  const len = ancestors.length;\n\n  for (let i = len - 1; i >= 0; i--) {\n    temp = ancestors[i];\n\n    if (temp.childNodes && i > 0) {\n      for (let j = 0; j < temp.childNodes.length; j++) {\n        if (temp.childNodes[j] === ancestors[i - 1]) {\n          key += '_s' + (j + 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return key;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectionToken} from '@angular/core';\n\nexport const PREBOOT_NONCE = new InjectionToken<string>('PrebootNonce');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  NodeContext,\n  PrebootAppData,\n  PrebootData,\n  PrebootEvent,\n  PrebootWindow,\n  ServerClientRoot,\n} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\nexport function _window(): PrebootWindow {\n  return {\n    prebootData: (window as any)['prebootData'],\n    prebootStarted: false,\n    getComputedStyle: window.getComputedStyle,\n    document: document\n  };\n}\n\nexport class EventReplayer {\n  clientNodeCache: { [key: string]: Element } = {};\n  replayStarted = false;\n  win: PrebootWindow;\n\n  /**\n   * Window setting and getter to facilitate testing of window\n   * in non-browser environments\n   */\n  setWindow(win: PrebootWindow) {\n    this.win = win;\n  }\n\n  /**\n   * Window setting and getter to facilitate testing of window\n   * in non-browser environments\n   */\n  getWindow() {\n    if (!this.win) {\n      this.win = _window();\n    }\n    return this.win;\n  }\n\n  /**\n   * Replay all events for all apps. this can only be run once.\n   * if called multiple times, will only do something once\n   */\n  replayAll() {\n    if (this.replayStarted) {\n      return;\n    } else {\n      this.replayStarted = true;\n    }\n\n    // loop through each of the preboot apps\n    const prebootData = this.getWindow().prebootData || {};\n    const apps = prebootData.apps || [];\n    apps.forEach(appData => this.replayForApp(appData));\n\n    // once all events have been replayed and buffers switched, then we cleanup preboot\n    this.cleanup(prebootData);\n  }\n\n  /**\n   * Replay all events for one app (most of the time there is just one app)\n   * @param appData\n   */\n  replayForApp(appData: PrebootAppData) {\n    appData = <PrebootAppData>(appData || {});\n\n    // try catch around events b/c even if error occurs, we still move forward\n    try {\n      const root = <ServerClientRoot>(appData.root || {});\n      const events = appData.events || [];\n\n      // some client side frameworks (like Angular 1 w UI Router) will replace\n      // elements, so we need to re-get client root just to be safe\n      const doc = this.getWindow().document;\n      const clientSelector = root.clientSelector;\n      if (clientSelector != null) {\n        root.clientNode = doc.querySelector(clientSelector) as HTMLElement;\n      }\n\n      // replay all the events from the server view onto the client view\n      events.forEach(event => this.replayEvent(appData, event));\n    } catch (ex) {\n      console.error(ex);\n    }\n\n    // if we are buffering, switch the buffers\n    this.switchBuffer(appData);\n  }\n\n  /**\n   * Replay one particular event\n   * @param appData\n   * @param prebootEvent\n   */\n  replayEvent(appData: PrebootAppData, prebootEvent: PrebootEvent) {\n    appData = <PrebootAppData>(appData || {});\n    prebootEvent = <PrebootEvent>(prebootEvent || {});\n\n    const event = prebootEvent.event as Event;\n    const serverNode = prebootEvent.node || {};\n    const nodeKey = prebootEvent.nodeKey;\n    const clientNode = this.findClientNode({\n      root: appData.root,\n      node: serverNode,\n      nodeKey: nodeKey\n    });\n\n    // if client node can't be found, log a warning\n    if (!clientNode) {\n      console.warn(\n        `Trying to dispatch event ${event.type} to node ${nodeKey}\n        but could not find client node. Server node is: ${serverNode}`\n      );\n      return;\n    }\n\n    // now dispatch events and whatnot to the client node\n    (clientNode as HTMLInputElement).checked = serverNode.checked;\n    (clientNode as HTMLOptionElement).selected = serverNode.selected;\n    (clientNode as HTMLOptionElement).value = serverNode.value;\n    clientNode.dispatchEvent(event);\n  }\n\n  /**\n   * Switch the buffer for one particular app (i.e. display the client\n   * view and destroy the server view)\n   * @param appData\n   */\n  switchBuffer(appData: PrebootAppData) {\n    appData = <PrebootAppData>(appData || {});\n\n    const root = <ServerClientRoot>(appData.root || {});\n    const serverView = root.serverNode;\n    const clientView = root.clientNode;\n\n    // if no client view or the server view is the body or client\n    // and server view are the same, then don't do anything and return\n    if (!clientView || !serverView || serverView === clientView || serverView.nodeName === 'BODY') {\n      return;\n    }\n\n    // do a try-catch just in case something messed up\n    try {\n      // get the server view display mode\n      const gcs = this.getWindow().getComputedStyle;\n      const display = gcs(serverView).getPropertyValue('display') || 'block';\n\n      // first remove the server view\n      serverView.remove ? serverView.remove() : (serverView.style.display = 'none');\n\n      // now add the client view\n      clientView.style.display = display;\n    } catch (ex) {\n      console.error(ex);\n    }\n  }\n\n  /**\n   * Finally, set focus, remove all the event listeners and remove\n   * any freeze screen that may be there\n   * @param prebootData\n   */\n  cleanup(prebootData: PrebootData) {\n    prebootData = prebootData || {};\n\n    const listeners = prebootData.listeners || [];\n\n    // set focus on the active node AFTER a small delay to ensure buffer\n    // switched\n    const activeNode = prebootData.activeNode;\n    if (activeNode != null) {\n      setTimeout(() => this.setFocus(activeNode), 1);\n    }\n\n    // remove all event listeners\n    for (const listener of listeners) {\n      listener.node.removeEventListener(listener.eventName, listener.handler);\n    }\n\n    // remove the freeze overlay if it exists\n    const doc = this.getWindow().document;\n    const prebootOverlay = doc.body.querySelector('#prebootOverlay') as HTMLElement;\n    if (prebootOverlay) {\n      prebootOverlay.remove ?\n        prebootOverlay.remove() : prebootOverlay.parentNode !== null ?\n        prebootOverlay.parentNode.removeChild(prebootOverlay) :\n        prebootOverlay.style.display = 'none';\n    }\n\n    // clear out the data stored for each app\n    prebootData.apps = [];\n    this.clientNodeCache = {};\n\n    // send event to document that signals preboot complete\n    // constructor is not supported by older browsers ( i.e. IE9-11 )\n    // in these browsers, the type of CustomEvent will be \"object\"\n    if (typeof CustomEvent === 'function') {\n      const completeEvent = new CustomEvent('PrebootComplete');\n      doc.dispatchEvent(completeEvent);\n    } else {\n      console.warn(`Could not dispatch PrebootComplete event.\n       You can fix this by including a polyfill for CustomEvent.`);\n    }\n  }\n\n  setFocus(activeNode: NodeContext) {\n    // only do something if there is an active node\n    if (!activeNode || !activeNode.node || !activeNode.nodeKey) {\n      return;\n    }\n\n    // find the client node in the new client view\n    const clientNode = this.findClientNode(activeNode);\n    if (clientNode) {\n      // set focus on the client node\n      clientNode.focus();\n\n      // set selection if a modern browser (i.e. IE9+, etc.)\n      const selection = activeNode.selection;\n      if ((clientNode as HTMLInputElement).setSelectionRange && selection) {\n        try {\n          (clientNode as HTMLInputElement)\n            .setSelectionRange(selection.start, selection.end, selection.direction);\n        } catch (ex) {}\n      }\n    }\n  }\n\n  /**\n   * Given a node from the server rendered view, find the equivalent\n   * node in the client rendered view. We do this by the following approach:\n   *      1. take the name of the server node tag (ex. div or h1 or input)\n   *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)\n   *      3. use that value as a selector to get all the matching client nodes\n   *      4. loop through all client nodes found and for each generate a key value\n   *      5. compare the client key to the server key; once there is a match,\n   *          we have our client node\n   *\n   * NOTE: this only works when the client view is almost exactly the same as\n   * the server view. we will need an improvement here in the future to account\n   * for situations where the client view is different in structure from the\n   * server view\n   */\n  findClientNode(serverNodeContext: NodeContext): HTMLElement | null {\n    serverNodeContext = <NodeContext>(serverNodeContext || {});\n\n    const serverNode = serverNodeContext.node;\n    const root = serverNodeContext.root;\n\n    // if no server or client root, don't do anything\n    if (!root || !root.serverNode || !root.clientNode) {\n      return null;\n    }\n\n    // we use the string of the node to compare to the client node & as key in\n    // cache\n    const serverNodeKey = serverNodeContext.nodeKey || getNodeKeyForPreboot(serverNodeContext);\n\n    // if client node already in cache, return it\n    if (this.clientNodeCache[serverNodeKey]) {\n      return this.clientNodeCache[serverNodeKey] as HTMLElement;\n    }\n\n    // get the selector for client nodes\n    const className = (serverNode.className || '').replace('ng-binding', '').trim();\n    let selector = serverNode.tagName;\n\n    if (serverNode.id) {\n      selector += `#${serverNode.id}`;\n    } else if (className) {\n      selector += `.${className.replace(/ /g, '.')}`;\n    }\n\n    // select all possible client nodes and look through them to try and find a\n    // match\n    const rootClientNode = root.clientNode;\n    let clientNodes = rootClientNode.querySelectorAll(selector);\n\n    // if nothing found, then just try the tag name as a final option\n    if (!clientNodes.length) {\n      console.log(`nothing found for ${selector} so using ${serverNode.tagName}`);\n      clientNodes = rootClientNode.querySelectorAll(serverNode.tagName);\n    }\n\n    const length = clientNodes.length;\n    for (let i = 0; i < length; i++) {\n      const clientNode = clientNodes.item(i);\n\n      // get the key for the client node\n      const clientNodeKey = getNodeKeyForPreboot({\n        root: root,\n        node: clientNode\n      });\n\n      // if the client node key is exact match for the server node key, then we\n      // found the client node\n      if (clientNodeKey === serverNodeKey) {\n        this.clientNodeCache[serverNodeKey] = clientNode;\n        return clientNode as HTMLElement;\n      }\n    }\n\n    // if we get here and there is one clientNode, use it as a fallback\n    if (clientNodes.length === 1) {\n      this.clientNodeCache[serverNodeKey] = clientNodes[0];\n      return clientNodes[0] as HTMLElement;\n    }\n\n    // if we get here it means we couldn't find the client node so give the user\n    // a warning\n    console.warn(\n      `No matching client node found for ${serverNodeKey}.\n       You can fix this by assigning this element a unique id attribute.`\n    );\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  EventSelector,\n  PrebootOptions,\n  PrebootAppData,\n  PrebootData,\n  DomEvent,\n  PrebootWindow,\n  ServerClientRoot,\n  PrebootSelection,\n} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\n/**\n * Called right away to initialize preboot\n *\n * @param opts All the preboot options\n * @param win\n */\nexport function init(opts: PrebootOptions, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n\n  // add the preboot options to the preboot data and then add the data to\n  // the window so it can be used later by the client\n  const data = (theWindow.prebootData = <PrebootData>{\n    opts: opts,\n    listening: true,\n    apps: [],\n    listeners: []\n  });\n\n  // start up preboot listening as soon as the DOM is ready\n  waitUntilReady(data);\n}\n\n/**\n * We want to attach event handlers as soon as possible. Unfortunately this\n * means before DOMContentLoaded fires, so we need to look for document.body to\n * exist instead.\n * @param data\n * @param win\n */\nexport function waitUntilReady(data: PrebootData, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n  const _document = <Document>(theWindow.document || {});\n\n  if (_document.body) {\n    start(data);\n  } else {\n    setTimeout(function() {\n      waitUntilReady(data);\n    }, 10);\n  }\n}\n\n/**\n * Start up preboot by going through each app and assigning the appropriate\n * handlers. Normally this wouldn't be called directly, but we have set it up so\n * that it can for older versions of Universal.\n *\n * @param prebootData Global preboot data object that contains options and will\n * have events\n * @param win Optional param to pass in mock window for testing purposes\n */\nexport function start(prebootData: PrebootData, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n\n  // only start once\n  if (theWindow.prebootStarted) {\n    return;\n  } else {\n    theWindow.prebootStarted = true;\n  }\n\n  const _document = <Document>(theWindow.document || {});\n  const opts = prebootData.opts || ({} as PrebootOptions);\n  let eventSelectors = opts.eventSelectors || [];\n\n  // create an overlay that can be used later if a freeze event occurs\n  prebootData.overlay = createOverlay(_document);\n\n  // get an array of all the root info\n  const appRoots = prebootData.opts ? getAppRoots(_document, prebootData.opts) : [];\n\n  // for each app root\n  appRoots.forEach(function(root) {\n    // we track all events for each app in the prebootData object which is on\n    // the global scope\n    const appData = <PrebootAppData>{ root: root, events: [] };\n    if (prebootData.apps) {\n      prebootData.apps.push(appData);\n    }\n\n    eventSelectors = eventSelectors.map(eventSelector => {\n      if (!eventSelector.hasOwnProperty('replay')) {\n        eventSelector.replay = true;\n      }\n      return eventSelector;\n    });\n\n    // loop through all the eventSelectors and create event handlers\n    eventSelectors.forEach(eventSelector => handleEvents(prebootData, appData, eventSelector));\n  });\n}\n\n/**\n * Create an overlay div and add it to the DOM so it can be used\n * if a freeze event occurs\n *\n * @param _document The global document object (passed in for testing purposes)\n * @returns Element The overlay node is returned\n */\nexport function createOverlay(_document: Document): Element | undefined {\n  let overlay = _document.createElement('div');\n  overlay.setAttribute('id', 'prebootOverlay');\n  overlay.setAttribute(\n    'style',\n    'display:none;position:absolute;left:0;' +\n    'top:0;width:100%;height:100%;z-index:999999;background:black;opacity:.3'\n  );\n  _document.body.appendChild(overlay);\n\n  return overlay;\n}\n\n/**\n * Get references to all app root nodes based on input options. Users can\n * initialize preboot either by specifying appRoot which is just one or more\n * selectors for apps. This section option is useful for people that are doing their own\n * buffering (i.e. they have their own client and server view)\n *\n * @param _document The global document object passed in for testing purposes\n * @param opts Options passed in by the user to init()\n * @returns ServerClientRoot[] An array of root info for each app\n */\nexport function getAppRoots(_document: Document, opts: PrebootOptions): ServerClientRoot[] {\n  const roots: ServerClientRoot[] = [];\n\n  // loop through any appRoot selectors to add them to the list of roots\n  if (opts.appRoot && opts.appRoot.length) {\n    const baseList: string[] = [];\n    const appRootSelectors = baseList.concat(opts.appRoot);\n    appRootSelectors.forEach((selector: any) => roots.push({ serverSelector: selector }));\n  }\n\n  // now loop through the roots to get the nodes for each root\n  roots.forEach(root => {\n    root.serverNode = _document.querySelector(root.serverSelector) as HTMLElement;\n    root.clientSelector = root.clientSelector || root.serverSelector;\n\n    if (root.clientSelector !== root.serverSelector) {\n      // if diff selectors, then just get the client node\n      root.clientNode = _document.querySelector(root.clientSelector) as HTMLElement;\n    } else {\n      // if we are doing buffering, we need to create the buffer for the client\n      // else the client root is the same as the server\n      root.clientNode = opts.buffer ? createBuffer(root) : root.serverNode;\n    }\n\n    // if no server node found, log error\n    if (!root.serverNode) {\n      console.log(`No server node found for selector: ${root.serverSelector}`);\n    }\n  });\n\n  return roots;\n}\n\n/**\n * Under given server root, for given selector, record events\n *\n * @param prebootData\n * @param appData\n * @param eventSelector\n */\nexport function handleEvents(prebootData: PrebootData,\n                             appData: PrebootAppData,\n                             eventSelector: EventSelector) {\n  const serverRoot = appData.root.serverNode;\n\n  // don't do anything if no server root\n  if (!serverRoot) {\n    return;\n  }\n\n  // get all nodes under the server root that match the given selector\n  const nodes: NodeListOf<Element> = serverRoot.querySelectorAll(eventSelector.selector);\n\n  // don't do anything if no nodes found\n  if (!nodes) {\n    return;\n  }\n\n  // we want to add an event listener for each node and each event\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes.item(i);\n    eventSelector.events.forEach((eventName: string) => {\n      // get the appropriate handler and add it as an event listener\n      const handler = createListenHandler(prebootData, eventSelector, appData, node);\n      node.addEventListener(eventName, handler);\n\n      // need to keep track of listeners so we can do node.removeEventListener()\n      // when preboot done\n      if (prebootData.listeners) {\n        prebootData.listeners.push({\n          node: node as HTMLElement,\n          eventName,\n          handler\n        });\n      }\n    });\n  }\n}\n\n/**\n * Create handler for events that we will record\n */\nexport function createListenHandler(\n  prebootData: PrebootData,\n  eventSelector: EventSelector,\n  appData: PrebootAppData,\n  node: Element\n): EventListener {\n  const CARET_EVENTS = ['keyup', 'keydown', 'focusin', 'mouseup', 'mousedown'];\n  const CARET_NODES = ['INPUT', 'TEXTAREA'];\n\n  return function(event: DomEvent) {\n    const root = appData.root;\n    const eventName = event.type;\n\n    // if no node or no event name or not listening, just return\n    if (!node || !eventName) {\n      return;\n    }\n\n    // if key codes set for eventSelector, then don't do anything if event\n    // doesn't include key\n    const keyCodes = eventSelector.keyCodes;\n    if (keyCodes && keyCodes.length) {\n      const matchingKeyCodes = keyCodes.filter(keyCode => event.which === keyCode);\n\n      // if there are not matches (i.e. key entered NOT one of the key codes)\n      // then don't do anything\n      if (!matchingKeyCodes.length) {\n        return;\n      }\n    }\n\n    // if for a given set of events we are preventing default, do that\n    if (eventSelector.preventDefault) {\n      event.preventDefault();\n    }\n\n    // if an action handler passed in, use that\n    if (eventSelector.action) {\n      eventSelector.action(node, event);\n    }\n\n    // get the node key for a given node\n    const nodeKey = getNodeKeyForPreboot({ root: root, node: node });\n\n    // if event on input or text area, record active node\n    if (CARET_EVENTS.indexOf(eventName) >= 0 &&\n      CARET_NODES.indexOf(node.tagName ? node.tagName : '') >= 0) {\n      prebootData.activeNode = {\n        root: root,\n        node: node,\n        nodeKey: nodeKey,\n        selection: getSelection(node as HTMLInputElement)\n      };\n    } else if (eventName !== 'change' && eventName !== 'focusout') {\n      prebootData.activeNode = undefined;\n    }\n\n    // if we are freezing the UI\n    if (eventSelector.freeze) {\n      const overlay = prebootData.overlay as HTMLElement;\n\n      // show the overlay\n      overlay.style.display = 'block';\n\n      // hide the overlay after 10 seconds just in case preboot.complete() never\n      // called\n      setTimeout(() => {\n        overlay.style.display = 'none';\n      }, 10000);\n    }\n\n    // we will record events for later replay unless explicitly marked as\n    // doNotReplay\n    if (eventSelector.replay) {\n      appData.events.push({\n        node,\n        nodeKey,\n        event,\n        name: eventName\n      });\n    }\n  };\n}\n\n/**\n * Get the selection data that is later used to set the cursor after client view\n * is active\n */\nexport function getSelection(node: HTMLInputElement): PrebootSelection {\n  node = node || {} as HTMLInputElement;\n\n  const nodeValue = node.value || '';\n  const selection = {\n    start: nodeValue.length,\n    end: nodeValue.length,\n    direction: 'forward'\n  };\n\n  // if browser support selectionStart on node (Chrome, FireFox, IE9+)\n  try {\n    if (node.selectionStart || node.selectionStart === 0) {\n      selection.start = node.selectionStart;\n      selection.end = node.selectionEnd ? node.selectionEnd : 0;\n      selection.direction = node.selectionDirection ? node.selectionDirection : '';\n    }\n  } catch (ex) {}\n\n  return selection;\n}\n\n/**\n * Create buffer for a given node\n *\n * @param root All the data related to a particular app\n * @returns Returns the root client node.\n */\nexport function createBuffer(root: ServerClientRoot): HTMLElement {\n  const serverNode = root.serverNode;\n\n  // if no rootServerNode OR the selector is on the entire html doc or the body\n  // OR no parentNode, don't buffer\n  if (!serverNode || !serverNode.parentNode ||\n    root.serverSelector === 'html' || root.serverSelector === 'body') {\n    return serverNode as HTMLElement;\n  }\n\n  // create shallow clone of server root\n  const rootClientNode = serverNode.cloneNode(false) as HTMLElement;\n  // we want the client to write to a hidden div until the time for switching\n  // the buffers\n  rootClientNode.style.display = 'none';\n\n  // insert the client node before the server and return it\n  serverNode.parentNode.insertBefore(rootClientNode, serverNode);\n\n  // mark server node as not to be touched by AngularJS - needed for ngUpgrade\n  serverNode.setAttribute('ng-non-bindable', '');\n\n  // return the rootClientNode\n  return rootClientNode;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {PrebootOptions} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\nimport {\n  init,\n  waitUntilReady,\n  start,\n  createOverlay,\n  getAppRoots,\n  handleEvents,\n  createListenHandler,\n  getSelection,\n  createBuffer\n} from './event.recorder';\n\nconst eventRecorder = {\n  waitUntilReady,\n  start,\n  createOverlay,\n  getAppRoots,\n  handleEvents,\n  createListenHandler,\n  getSelection,\n  createBuffer\n};\n\n// exporting default options in case developer wants to use these + custom on\n// top\nexport const defaultOptions = <PrebootOptions>{\n  buffer: true,\n  minify: true,\n  replay: true,\n\n  // these are the default events are are listening for an transfering from\n  // server view to client view\n  eventSelectors: [\n    // for recording changes in form elements\n    {\n      selector: 'input,textarea',\n      events: ['keypress', 'keyup', 'keydown', 'input', 'change']\n    },\n    { selector: 'select,option', events: ['change'] },\n\n    // when user hits return button in an input box\n    {\n      selector: 'input',\n      events: ['keyup'],\n      preventDefault: true,\n      keyCodes: [13],\n      freeze: true\n    },\n\n    // when user submit form (press enter, click on button/input[type=\"submit\"])\n    {\n      selector: 'form',\n      events: ['submit'],\n      preventDefault: true,\n      freeze: true\n    },\n\n    // for tracking focus (no need to replay)\n    {\n      selector: 'input,textarea',\n      events: ['focusin', 'focusout', 'mousedown', 'mouseup'],\n      replay: false\n    },\n\n    // user clicks on a button\n    {\n      selector: 'button',\n      events: ['click'],\n      preventDefault: true,\n      freeze: true\n    }\n  ]\n};\n\n/**\n * Get the event recorder code based on all functions in event.recorder.ts\n * and the getNodeKeyForPreboot function.\n */\nexport function getEventRecorderCode(): string {\n  const eventRecorderFunctions: string[] = [];\n\n  for (const funcName in eventRecorder) {\n    if (eventRecorder.hasOwnProperty(funcName)) {\n      const fn = (<any>eventRecorder)[funcName].toString();\n      const fnCleaned = fn.replace('common_1.', '');\n      eventRecorderFunctions.push(fnCleaned);\n    }\n  }\n\n  // this is common function used to get the node key\n  eventRecorderFunctions.push(getNodeKeyForPreboot.toString());\n\n  // add new line characters for readability\n  return '\\n\\n' + eventRecorderFunctions.join('\\n\\n') + '\\n\\n';\n}\n\n\n/**\n * Used by the server side version of preboot. The main purpose\n * is to get the inline code that can be inserted into the server view.\n *\n * @param customOptions PrebootRecordOptions that override the defaults\n * @returns Generated inline preboot code is returned\n */\nexport function getInlinePrebootCode(customOptions?: PrebootOptions): string {\n  const opts = <PrebootOptions>assign({}, defaultOptions, customOptions);\n\n  // safety check to make sure options passed in are valid\n  validateOptions(opts);\n\n  const optsStr = stringifyWithFunctions(opts);\n  const scriptCode = getEventRecorderCode();\n\n  // TODO re-add minification option?\n\n  // wrap inline preboot code with a self executing function in order to create scope\n  const initStr = init.toString();\n  return `(function() {\n      ${scriptCode}\n      (${initStr.replace('common_1.', '')}\n      )(${optsStr})\n    })()`;\n}\n\n/**\n * Throw an error if issues with any options\n * @param opts\n */\nexport function validateOptions(opts: PrebootOptions) {\n  if (!opts.appRoot || !opts.appRoot.length) {\n    throw new Error(\n      'The appRoot is missing from preboot options. ' +\n        'This is needed to find the root of your application. ' +\n        'Set this value in the preboot options to be a selector for the root element of your app.'\n    );\n  }\n}\n\n/**\n * Object.assign() is not fully supporting in TypeScript, so\n * this is just a simple implementation of it\n *\n * @param target The target object\n * @param optionSets Any number of addition objects that are added on top of the\n * target\n * @returns A new object that contains all the merged values\n */\nexport function assign(target: Object, ...optionSets: any[]): Object {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n\n  const output = Object(target);\n  for (let index = 0; index < optionSets.length; index++) {\n    const source = optionSets[index];\n    if (source !== undefined && source !== null) {\n      for (const nextKey in source) {\n        if (source.hasOwnProperty && source.hasOwnProperty(nextKey)) {\n          output[nextKey] = source[nextKey];\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\n/**\n * Stringify an object and include functions. This is needed since we are\n * letting users pass in options that include custom functions for things like\n * the freeze handler or action when an event occurs\n *\n * @param obj This is the object you want to stringify that includes some\n * functions\n * @returns The stringified version of an object\n */\nexport function stringifyWithFunctions(obj: Object): string {\n  const FUNC_START = 'START_FUNCTION_HERE';\n  const FUNC_STOP = 'STOP_FUNCTION_HERE';\n\n  // first stringify except mark off functions with markers\n  let str = JSON.stringify(obj, function(_key, value) {\n    // if the value is a function, we want to wrap it with markers\n    if (!!(value && value.constructor && value.call && value.apply)) {\n      return FUNC_START + value.toString() + FUNC_STOP;\n    } else {\n      return value;\n    }\n  });\n\n  // now we use the markers to replace function strings with actual functions\n  let startFuncIdx = str.indexOf(FUNC_START);\n  let stopFuncIdx: number;\n  let fn: string;\n  while (startFuncIdx >= 0) {\n    stopFuncIdx = str.indexOf(FUNC_STOP);\n\n    // pull string out\n    fn = str.substring(startFuncIdx + FUNC_START.length, stopFuncIdx);\n    fn = fn.replace(/\\\\n/g, '\\n');\n\n    str = str.substring(0, startFuncIdx - 1) + fn +\n      str.substring(stopFuncIdx + FUNC_STOP.length + 1);\n    startFuncIdx = str.indexOf(FUNC_START);\n  }\n\n  return str;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  APP_BOOTSTRAP_LISTENER,\n  ApplicationRef,\n  Inject,\n  InjectionToken,\n  Optional,\n  PLATFORM_ID\n} from '@angular/core';\nimport {DOCUMENT, isPlatformBrowser, isPlatformServer} from '@angular/common';\nimport {take} from 'rxjs/operators/take';\nimport {filter} from 'rxjs/operators/filter';\n\nimport {EventReplayer} from './api/event.replayer';\nimport {PREBOOT_NONCE} from './common/tokens';\nimport {getInlinePrebootCode} from './api/inline.preboot.code';\nimport {PrebootOptions} from './common/preboot.interfaces';\n\nconst PREBOOT_SCRIPT_ID = 'preboot-inline-script';\nexport const PREBOOT_OPTIONS = new InjectionToken<PrebootOptions>('PrebootOptions');\n\nexport function PREBOOT_FACTORY(doc: Document,\n                                prebootOpts: PrebootOptions,\n                                nonce: string|null,\n                                platformId: Object,\n                                appRef: ApplicationRef,\n                                eventReplayer: EventReplayer) {\n  return () => {\n    if (isPlatformServer(platformId)) {\n      const inlineCode = getInlinePrebootCode(prebootOpts);\n      const script = doc.createElement('script');\n      if (nonce) {\n        (<any>script)['nonce'] = nonce;\n      }\n      script.id = PREBOOT_SCRIPT_ID;\n      script.textContent = inlineCode;\n      const existingScripts = doc.querySelectorAll(`#${PREBOOT_SCRIPT_ID}`);\n\n      // Check to see if a preboot script is already inlined before adding\n      // it to the DOM. If it is, update the nonce to be current\n      if (existingScripts.length === 0) {\n        doc.head.appendChild(script);\n      } else if (existingScripts.length > 0 && nonce) {\n        (<any>existingScripts[0])['nonce'] = nonce;\n      }\n    }\n    if (isPlatformBrowser(platformId)) {\n      const replay = prebootOpts.replay != null ? prebootOpts.replay : true;\n      if (replay) {\n        appRef.isStable\n          .pipe(\n            filter(stable => stable),\n            take(1)\n          ).subscribe(() => {\n          eventReplayer.replayAll();\n        });\n      }\n    }\n  };\n}\n\nexport const PREBOOT_PROVIDER = {\n  provide: <InjectionToken<() => void>>APP_BOOTSTRAP_LISTENER,\n  useFactory: PREBOOT_FACTORY,\n  deps: [\n    DOCUMENT,\n    PREBOOT_OPTIONS,\n    [new Optional(), new Inject(PREBOOT_NONCE)],\n    PLATFORM_ID,\n    ApplicationRef,\n    EventReplayer,\n  ],\n  multi: true\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {EventReplayer} from './api/event.replayer';\nimport {PrebootOptions} from './common/preboot.interfaces';\nimport {PREBOOT_OPTIONS, PREBOOT_PROVIDER} from './provider';\n\n@NgModule({\n  providers: [EventReplayer, PREBOOT_PROVIDER]\n})\nexport class PrebootModule {\n  static withConfig(opts: PrebootOptions): ModuleWithProviders {\n    return {\n      ngModule: PrebootModule,\n      providers: [{provide: PREBOOT_OPTIONS, useValue: opts}]\n    };\n  }\n}\n"],"names":["nodeContext","ancestors","root","node","temp","serverNode","clientNode","push","key","nodeName","serverSelector","i","length","childNodes","j","PREBOOT_NONCE","InjectionToken","prebootData","prebootStarted","getComputedStyle","window","document","EventReplayer","win","this","_window","replayStarted","getWindow","apps","forEach","appData","_this","replayForApp","cleanup","events","doc","clientSelector","querySelector","event","replayEvent","ex","console","error","switchBuffer","prebootEvent","nodeKey","findClientNode","checked","selected","value","dispatchEvent","warn","type","serverView","clientView","display","gcs","getPropertyValue","remove","style","listeners","activeNode","setTimeout","setFocus","listeners_1","_i","listener","removeEventListener","eventName","handler","prebootOverlay","body","parentNode","removeChild","clientNodeCache","CustomEvent","completeEvent","focus","selection","setSelectionRange","start","end","direction","serverNodeContext","serverNodeKey","getNodeKeyForPreboot","className","replace","trim","selector","tagName","id","rootClientNode","clientNodes","querySelectorAll","log","item","opts","waitUntilReady","listening","data","theWindow","_document","eventSelectors","overlay","createOverlay","getAppRoots","map","eventSelector","hasOwnProperty","replay","handleEvents","createElement","setAttribute","appendChild","roots","appRoot","concat","buffer","createBuffer","serverRoot","nodes","createListenHandler","addEventListener","CARET_EVENTS","CARET_NODES","keyCodes","filter","keyCode","which","preventDefault","action","indexOf","getSelection","undefined","freeze","overlay_1","name","nodeValue","selectionStart","selectionEnd","selectionDirection","cloneNode","insertBefore","eventRecorder","defaultOptions","minify","eventRecorderFunctions","funcName","fnCleaned","toString","join","customOptions","assign","validateOptions","optsStr","stringifyWithFunctions","getEventRecorderCode","init","Error","target","optionSets","TypeError","output","Object","index","source","nextKey","obj","stopFuncIdx","fn","FUNC_START","FUNC_STOP","str","JSON","stringify","_key","constructor","call","apply","startFuncIdx","substring","PREBOOT_SCRIPT_ID","PREBOOT_OPTIONS","prebootOpts","nonce","platformId","appRef","eventReplayer","isPlatformServer","inlineCode","getInlinePrebootCode","script","textContent","existingScripts","head","isPlatformBrowser","isStable","pipe","stable","take","subscribe","replayAll","PREBOOT_PROVIDER","provide","APP_BOOTSTRAP_LISTENER","useFactory","PREBOOT_FACTORY","deps","DOCUMENT","Optional","Inject","PLATFORM_ID","ApplicationRef","multi","PrebootModule","ngModule","providers","useValue","NgModule"],"mappings":"qcAYA,WAAqCA,GAOnC,IANA,IAAMC,KACAC,EAAOF,EAAYE,KACnBC,EAAOH,EAAYG,KACrBC,EAAuBD,EAGpBC,GAAQA,IAASF,EAAKG,YAAcD,IAASF,EAAKI,YACvDL,EAAUM,KAAKH,GACfA,EAAOA,EAA0B,WAI/BA,GACFH,EAAUM,KAAKH,GASjB,IAJA,IACII,GADSL,EAAKM,UAAY,WACb,IAAMP,EAAKQ,eAGnBC,EAFGV,EAAUW,OAEH,EAAGD,GAAK,EAAGA,IAG5B,IAFAP,EAAOH,EAAUU,IAERE,YAAcF,EAAI,EACzB,IAAK,IAAIG,EAAI,EAAGA,EAAIV,EAAKS,WAAWD,OAAQE,IAC1C,GAAIV,EAAKS,WAAWC,KAAOb,EAAUU,EAAI,GAAI,CAC3CH,GAAO,MAAQM,EAAI,GACnB,MAMR,OAAON,ECzCT,IAEaO,EAAgB,IAAIC,iBAAuB,gBCQxD,aACE,OACEC,YAAa,OAA6B,YAC1CC,gBAAgB,EAChBC,iBAAkBC,OAAOD,iBACzBE,SAAUA,UAId,IAAAC,sEAEkB,SAOhBA,sBAAA,SAAUC,GACRC,KAAKD,IAAMA,GAObD,sBAAA,WAIE,OAHKE,KAAKD,MACRC,KAAKD,IAAME,KAEND,KAAKD,KAOdD,sBAAA,WAAA,WACE,IAAIE,KAAKE,cAAT,CAGEF,KAAKE,eAAgB,EAIvB,IAAMT,EAAcO,KAAKG,YAAYV,iBACxBA,EAAYW,UACpBC,QAAQ,SAAAC,GAAW,OAAAC,EAAKC,aAAaF,KAG1CN,KAAKS,QAAQhB,KAOfK,yBAAA,SAAaQ,GAAb,WACEA,EAA2BA,MAG3B,IACE,IAAM5B,EAA0B4B,EAAQ5B,SAClCgC,EAASJ,EAAQI,WAIjBC,EAAMX,KAAKG,YAAYN,SACvBe,EAAiBlC,EAAKkC,eACN,MAAlBA,IACFlC,EAAKI,WAAa6B,EAAIE,cAAcD,IAItCF,EAAOL,QAAQ,SAAAS,GAAS,OAAAP,EAAKQ,YAAYT,EAASQ,KAClD,MAAOE,GACPC,QAAQC,MAAMF,GAIhBhB,KAAKmB,aAAab,IAQpBR,wBAAA,SAAYQ,EAAyBc,GACnCd,EAA2BA,MAG3B,IAAMQ,GAFNM,EAA8BA,OAEW,MACnCvC,EAAauC,EAAazC,SAC1B0C,EAAUD,EAAaC,QACvBvC,EAAakB,KAAKsB,gBACtB5C,KAAM4B,EAAQ5B,KACdC,KAAME,EACNwC,QAASA,IAINvC,GASL,EAAiCyC,QAAU1C,EAAW0C,QACtD,EAAkCC,SAAW3C,EAAW2C,SACxD,EAAkCC,MAAQ5C,EAAW4C,MACrD3C,EAAW4C,cAAcZ,IAXvBG,QAAQU,KACN,4BAA4Bb,EAAMc,iBAAgBP,+DACAxC,IAiBxDiB,yBAAA,SAAaQ,GAGX,IAAM5B,GAFN4B,EAA2BA,OAEa5B,SAClCmD,EAAanD,EAAKG,WAClBiD,EAAapD,EAAKI,WAIxB,GAAKgD,GAAeD,GAAcA,IAAeC,GAAsC,SAAxBD,EAAW5C,SAK1E,IAEE,IACM8C,GAAUC,EADJhC,KAAKG,YAAYR,kBACTkC,GAAYI,iBAAiB,YAAc,QAG/DJ,EAAWK,OAASL,EAAWK,SAAYL,EAAWM,MAAMJ,QAAU,OAGtED,EAAWK,MAAMJ,QAAUA,EAC3B,MAAOf,GACPC,QAAQC,MAAMF,KASlBlB,oBAAA,SAAQL,GAAR,WAGQ2C,GAFN3C,EAAcA,OAEgB2C,cAIxBC,EAAa5C,EAAY4C,WACb,MAAdA,GACFC,WAAW,WAAM,OAAA/B,EAAKgC,SAASF,IAAa,GAI9C,IAAuB,QAAAG,IAAAC,WAAAA,KAAlB,IAAMC,OACTA,EAAS/D,KAAKgE,oBAAoBD,EAASE,UAAWF,EAASG,SAIjE,IAAMlC,EAAMX,KAAKG,YAAYN,SACvBiD,EAAiBnC,EAAIoC,KAAKlC,cAAc,mBAe9C,GAdIiC,IACFA,EAAeZ,OACbY,EAAeZ,SAAyC,OAA9BY,EAAeE,WACzCF,EAAeE,WAAWC,YAAYH,GACtCA,EAAeX,MAAMJ,QAAU,QAInCtC,EAAYW,QACZJ,KAAKkD,mBAKsB,mBAAhBC,YAA4B,CACrC,IAAMC,EAAgB,IAAID,YAAY,mBACtCxC,EAAIe,cAAc0B,QAElBnC,QAAQU,KAAK,gHAKjB7B,qBAAA,SAASuC,GAEP,GAAKA,GAAeA,EAAW1D,MAAS0D,EAAWhB,QAAnD,CAKA,IAAMvC,EAAakB,KAAKsB,eAAee,GACvC,GAAIvD,EAAY,CAEdA,EAAWuE,QAGX,IAAMC,EAAYjB,EAAWiB,UAC7B,GAAI,EAAiCC,mBAAqBD,EACxD,IACE,EACGC,kBAAkBD,EAAUE,MAAOF,EAAUG,IAAKH,EAAUI,WAC/D,MAAO1C,QAoBflB,2BAAA,SAAe6D,GAGb,IAAM9E,GAFN8E,EAAkCA,OAEGhF,KAC/BD,EAAOiF,EAAkBjF,KAG/B,IAAKA,IAASA,EAAKG,aAAeH,EAAKI,WACrC,OAAO,KAKT,IAAM8E,EAAgBD,EAAkBtC,SAAWwC,EAAqBF,GAGxE,GAAI3D,KAAKkD,gBAAgBU,GACvB,OAAO5D,KAAKkD,gBAAgBU,GAI9B,IAAME,GAAajF,EAAWiF,WAAa,IAAIC,QAAQ,aAAc,IAAIC,OACrEC,EAAWpF,EAAWqF,QAEtBrF,EAAWsF,GACbF,GAAY,IAAIpF,EAAWsF,GAClBL,IACTG,GAAY,IAAIH,EAAUC,QAAQ,KAAM,MAK1C,IAAMK,EAAiB1F,EAAKI,WACxBuF,EAAcD,EAAeE,iBAAiBL,GAG7CI,EAAYjF,SACf6B,QAAQsD,IAAI,qBAAqBN,eAAqBpF,EAAWqF,SACjEG,EAAcD,EAAeE,iBAAiBzF,EAAWqF,UAI3D,IADA,IAAM9E,EAASiF,EAAYjF,OAClBD,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC/B,IAAML,EAAauF,EAAYG,KAAKrF,GAUpC,GAPsB0E,GACpBnF,KAAMA,EACNC,KAAMG,MAKc8E,EAEpB,OADA5D,KAAKkD,gBAAgBU,GAAiB9E,IAM1C,OAA2B,IAAvBuF,EAAYjF,QACdY,KAAKkD,gBAAgBU,GAAiBS,EAAY,GAC3CA,EAAY,KAKrBpD,QAAQU,KACN,qCAAqCiC,iFAGhC,YC5SX,WAAqBa,EAAsB1E,GAazC2E,GAZkC3E,GAAOH,QAIjBH,aACtBgF,KAAMA,EACNE,WAAW,EACXvE,QACAgC,eAcJ,WAA+BwC,EAAmB7E,KACdA,GAAOH,QACFC,cAEzBkD,KACZS,EAAMoB,GAENtC,WAAW,WACToC,EAAeE,IACd,IAaP,WAAsBnF,EAA0BM,GAC9C,IAAM8E,EAA4B9E,GAAOH,OAGzC,IAAIiF,EAAUnF,eAAd,CAGEmF,EAAUnF,gBAAiB,EAG7B,IAAMoF,EAAuBD,EAAUhF,aAEnCkF,GADStF,EAAYgF,UACCM,mBAG1BtF,EAAYuF,QAAUC,EAAcH,IAGnBrF,EAAYgF,KAAOS,EAAYJ,EAAWrF,EAAYgF,UAG9DpE,QAAQ,SAAS3B,GAGxB,IAAM4B,GAA4B5B,KAAMA,EAAMgC,WAC1CjB,EAAYW,MACdX,EAAYW,KAAKrB,KAAKuB,IAGxByE,EAAiBA,EAAeI,IAAI,SAAAC,GAIlC,OAHKA,EAAcC,eAAe,YAChCD,EAAcE,QAAS,GAElBF,KAIM/E,QAAQ,SAAA+E,GAAiB,OAAAG,EAAa9F,EAAaa,EAAS8E,QAW/E,WAA8BN,GAC5B,IAAIE,EAAUF,EAAUU,cAAc,OAStC,OARAR,EAAQS,aAAa,KAAM,kBAC3BT,EAAQS,aACN,QACA,iHAGFX,EAAU/B,KAAK2C,YAAYV,GAEpBA,EAaT,WAA4BF,EAAqBL,GAC/C,IAAMkB,KAGN,GAAIlB,EAAKmB,SAAWnB,EAAKmB,QAAQxG,OAAQ,IAELyG,OAAOpB,EAAKmB,SAC7BvF,QAAQ,SAAC4D,GAAkB,OAAA0B,EAAM5G,MAAOG,eAAgB+E,MAuB3E,OAnBA0B,EAAMtF,QAAQ,SAAA3B,GACZA,EAAKG,WAAaiG,EAAUjE,cAAcnC,EAAKQ,gBAC/CR,EAAKkC,eAAiBlC,EAAKkC,gBAAkBlC,EAAKQ,eAE9CR,EAAKkC,iBAAmBlC,EAAKQ,eAE/BR,EAAKI,WAAagG,EAAUjE,cAAcnC,EAAKkC,gBAI/ClC,EAAKI,WAAa2F,EAAKqB,OAASC,EAAarH,GAAQA,EAAKG,WAIvDH,EAAKG,YACRoC,QAAQsD,IAAI,sCAAsC7F,EAAKQ,kBAIpDyG,EAUT,WAA6BlG,EACAa,EACA8E,GAC3B,IAAMY,EAAa1F,EAAQ5B,KAAKG,WAGhC,GAAKmH,EAAL,CAKA,IAAMC,EAA6BD,EAAW1B,iBAAiBc,EAAcnB,UAG7E,GAAKgC,EAKL,mBAAS9G,GACP,IAAMR,EAAOsH,EAAMzB,KAAKrF,GACxBiG,EAAc1E,OAAOL,QAAQ,SAACuC,GAE5B,IAAMC,EAAUqD,EAAoBzG,EAAa2F,EAAe9E,EAAS3B,GACzEA,EAAKwH,iBAAiBvD,EAAWC,GAI7BpD,EAAY2C,WACd3C,EAAY2C,UAAUrD,MACpBJ,OACAiE,YACAC,eAbC1D,EAAI,EAAGA,EAAI8G,EAAM7G,OAAQD,MAAzBA,IAuBX,WACEM,EACA2F,EACA9E,EACA3B,GAEA,IAAMyH,GAAgB,QAAS,UAAW,UAAW,UAAW,aAC1DC,GAAe,QAAS,YAE9B,OAAO,SAASvF,GACd,IAAMpC,EAAO4B,EAAQ5B,KACfkE,EAAY9B,EAAMc,KAGxB,GAAKjD,GAASiE,EAAd,CAMA,IAAM0D,EAAWlB,EAAckB,SAC/B,GAAIA,GAAYA,EAASlH,OAKvB,IAJyBkH,EAASC,OAAO,SAAAC,GAAW,OAAA1F,EAAM2F,QAAUD,IAI9CpH,OACpB,OAKAgG,EAAcsB,gBAChB5F,EAAM4F,iBAIJtB,EAAcuB,QAChBvB,EAAcuB,OAAOhI,EAAMmC,GAI7B,IAAMO,EAAUwC,GAAuBnF,KAAMA,EAAMC,KAAMA,IAgBzD,GAbIyH,EAAaQ,QAAQhE,IAAc,GACrCyD,EAAYO,QAAQjI,EAAKuF,QAAUvF,EAAKuF,QAAU,KAAO,EACzDzE,EAAY4C,YACV3D,KAAMA,EACNC,KAAMA,EACN0C,QAASA,EACTiC,UAAWuD,MAEU,WAAdjE,GAAwC,aAAdA,IACnCnD,EAAY4C,gBAAayE,GAIvB1B,EAAc2B,OAAQ,CACxB,IAAMC,EAAUvH,EAAkC,QAGlDuH,EAAQ7E,MAAMJ,QAAU,QAIxBO,WAAW,WACT0E,EAAQ7E,MAAMJ,QAAU,QACvB,KAKDqD,EAAcE,QAChBhF,EAAQI,OAAO3B,MACbJ,OACA0C,UACAP,QACAmG,KAAMrE,MAUd,WAA6BjE,GAG3B,IAAMuI,GAFNvI,EAAOA,OAEgB8C,OAAS,GAC1B6B,GACJE,MAAO0D,EAAU9H,OACjBqE,IAAKyD,EAAU9H,OACfsE,UAAW,WAIb,KACM/E,EAAKwI,gBAA0C,IAAxBxI,EAAKwI,kBAC9B7D,EAAUE,MAAQ7E,EAAKwI,eACvB7D,EAAUG,IAAM9E,EAAKyI,aAAezI,EAAKyI,aAAe,EACxD9D,EAAUI,UAAY/E,EAAK0I,mBAAqB1I,EAAK0I,mBAAqB,IAE5E,MAAOrG,IAET,OAAOsC,EAST,WAA6B5E,GAC3B,IAAMG,EAAaH,EAAKG,WAIxB,IAAKA,IAAeA,EAAWmE,YACL,SAAxBtE,EAAKQ,gBAAqD,SAAxBR,EAAKQ,eACvC,SAIF,IAAMkF,EAAiBvF,EAAWyI,WAAU,GAY5C,OATAlD,EAAejC,MAAMJ,QAAU,OAG/BlD,EAAWmE,WAAWuE,aAAanD,EAAgBvF,GAGnDA,EAAW4G,aAAa,kBAAmB,IAGpCrB,EClWT,IAcMoD,GACJ9C,iBACAlB,QACAyB,gBACAC,cACAK,eACAW,sBACAW,eACAd,gBAKW0B,GACX3B,QAAQ,EACR4B,QAAQ,EACRpC,QAAQ,EAIRP,iBAGId,SAAU,iBACVvD,QAAS,WAAY,QAAS,UAAW,QAAS,YAElDuD,SAAU,gBAAiBvD,QAAS,YAIpCuD,SAAU,QACVvD,QAAS,SACTgG,gBAAgB,EAChBJ,UAAW,IACXS,QAAQ,IAKR9C,SAAU,OACVvD,QAAS,UACTgG,gBAAgB,EAChBK,QAAQ,IAKR9C,SAAU,iBACVvD,QAAS,UAAW,WAAY,YAAa,WAC7C4E,QAAQ,IAKRrB,SAAU,SACVvD,QAAS,SACTgG,gBAAgB,EAChBK,QAAQ,KASd,aACE,IAAMY,KAEN,IAAK,IAAMC,KAAYJ,EACrB,GAAIA,EAAcnC,eAAeuC,GAAW,CAC1C,IACMC,EADK,EAAqBD,GAAUE,WACrB/D,QAAQ,YAAa,IAC1C4D,EAAuB5I,KAAK8I,GAQhC,OAHAF,EAAuB5I,KAAK8E,EAAqBiE,YAG1C,OAASH,EAAuBI,KAAK,QAAU,OAWxD,WAAqCC,GACnC,IAAMvD,EAAuBwD,KAAWR,EAAgBO,GAGxDE,EAAgBzD,GAEhB,IAAM0D,EAAUC,EAAuB3D,GAOvC,MAAO,wBANY4D,gBAKHC,EAAKR,WAGN/D,QAAQ,YAAa,iBAC5BoE,gBAQV,WAAgC1D,GAC9B,IAAKA,EAAKmB,UAAYnB,EAAKmB,QAAQxG,OACjC,MAAM,IAAImJ,MACR,8LAgBN,WAAuBC,OAAgB,aAAA/F,mBAAAA,IAAAgG,oBACrC,QAAe3B,IAAX0B,GAAmC,OAAXA,EAC1B,MAAM,IAAIE,UAAU,8CAItB,IADA,IAAMC,EAASC,OAAOJ,GACbK,EAAQ,EAAGA,EAAQJ,EAAWrJ,OAAQyJ,IAAS,CACtD,IAAMC,EAASL,EAAWI,GAC1B,QAAe/B,IAAXgC,GAAmC,OAAXA,EAC1B,IAAK,IAAMC,KAAWD,EAChBA,EAAOzD,gBAAkByD,EAAOzD,eAAe0D,KACjDJ,EAAOI,GAAWD,EAAOC,IAMjC,OAAOJ,EAYT,WAAuCK,GAkBrC,IAjBA,IAeIC,EACAC,EAhBEC,EAAa,sBACbC,EAAY,qBAGdC,EAAMC,KAAKC,UAAUP,EAAK,SAASQ,EAAM/H,GAE3C,OAAOA,GAASA,EAAMgI,aAAehI,EAAMiI,MAAQjI,EAAMkI,MAChDR,EAAa1H,EAAMqG,WAAasB,EAEhC3H,IAKPmI,EAAeP,EAAIzC,QAAQuC,GAGxBS,GAAgB,GACrBX,EAAcI,EAAIzC,QAAQwC,GAI1BF,GADAA,EAAKG,EAAIQ,UAAUD,EAAeT,EAAW/J,OAAQ6J,IAC7ClF,QAAQ,OAAQ,MAIxB6F,GAFAP,EAAMA,EAAIQ,UAAU,EAAGD,EAAe,GAAKV,EACzCG,EAAIQ,UAAUZ,EAAcG,EAAUhK,OAAS,IAC9BwH,QAAQuC,GAG7B,OAAOE,ECjNT,IAiBMS,EAAoB,wBACbC,EAAkB,IAAIvK,iBAA+B,kBAElE,WAAgCmB,EACAqJ,EACAC,EACAC,EACAC,EACAC,GAC9B,OAAO,WACL,GAAIC,mBAAiBH,GAAa,CAChC,IAAMI,EAAaC,EAAqBP,GAClCQ,EAAS7J,EAAI6E,cAAc,UAC7ByE,IACF,EAAqB,MAAIA,GAE3BO,EAAOrG,GAAK2F,EACZU,EAAOC,YAAcH,EACrB,IAAMI,EAAkB/J,EAAI2D,iBAAiB,IAAIwF,GAIlB,IAA3BY,EAAgBtL,OAClBuB,EAAIgK,KAAKjF,YAAY8E,GACZE,EAAgBtL,OAAS,GAAK6K,IACjCS,EAAgB,GAAW,MAAIT,GAGrCW,oBAAkBV,MACiB,MAAtBF,EAAY1E,QAAiB0E,EAAY1E,SAEtD6E,EAAOU,SACJC,KACCvE,SAAO,SAAAwE,GAAU,OAAAA,IACjBC,OAAK,IACLC,UAAU,WACZb,EAAcc,gBAOxB,IAAaC,GACXC,QAAqCC,EAAsB,uBAC3DC,WAAYC,EACZC,MACEC,WACA1B,GACC,IAAI2B,WAAY,IAAIC,SAAOpM,IAC5BqM,cACAC,iBACA/L,GAEFgM,OAAO,qCC7DAC,aAAP,SAAkBtH,GAChB,OACEuH,SAAUD,EACVE,YAAab,QAASrB,EAAiBmC,SAAUzH,0BAPtD0H,kBACCF,WAAYnM,EAAeqL"}